

# --- File: ./Cargo.toml ---

[package]
name = "CodeFlattener"
version = "0.1.1"
edition = "2024"

[dependencies]
anyhow = "1.0.98"
clap = { version = "4.5.40", features = ["derive", "cargo"] }
ignore = "0.4.23"
once_cell = "1.21.3"
tiktoken-rs = "0.7.0"


# --- File: ./Cargo.lock ---

# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "CodeFlattener"
version = "0.1.1"
dependencies = [
 "anyhow",
 "clap",
 "ignore",
 "once_cell",
 "tiktoken-rs",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "anstream"
version = "0.6.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "301af1932e46185686725e0fad2f8f2aa7da69dd70bf6ecc44d6b703844a3933"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c8bdeb6047d8983be085bab0ba1472e6dc604e7041dbf6fcd5e71523014fae9"
dependencies = [
 "windows-sys",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "403f75924867bb1033c59fbf0797484329750cfbe3c4325cd33127941fabc882"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys",
]

[[package]]
name = "anyhow"
version = "1.0.98"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16d2d3311acee920a9eb8d33b8cbc1787ce4a264e85f964c2404b969bdcd487"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bit-set"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0700ddab506f33b20a03b13996eccd309a48e5ff77d0d95926aa0210fb4e95f1"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"

[[package]]
name = "bstr"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "234113d19d0d7d613b40e86fb654acf958910802bcceab913a4f9e7cda03b1a4"
dependencies = [
 "memchr",
 "regex-automata",
 "serde",
]

[[package]]
name = "clap"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40b6887a1d8685cebccf115538db5c0efe625ccac9696ad45c409d96566e910f"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0c66c08ce9f0c698cbce5c0279d0bb6ac936d8674174fe48f736533b964f59e"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2c7947ae4cc3d851207c1adb5b5e260ff0cca11446b1d6d1423788e442257ce"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "fancy-regex"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "531e46835a22af56d1e3b66f04844bed63158bc094a628bec1d321d9b4c44bf2"
dependencies = [
 "bit-set",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "globset"
version = "0.4.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54a1028dfc5f5df5da8a56a73e6c153c9a9708ec57232470703592a3f18e49f5"
dependencies = [
 "aho-corasick",
 "bstr",
 "log",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "ignore"
version = "0.4.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d89fd380afde86567dfba715db065673989d6253f42b88179abd3eae47bda4b"
dependencies = [
 "crossbeam-deque",
 "globset",
 "log",
 "memchr",
 "regex-automata",
 "same-file",
 "walkdir",
 "winapi-util",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "2.0.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17b6f705963418cdb9927482fa304bc562ece2fdd4f616084c50b7023b435a40"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tiktoken-rs"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25563eeba904d770acf527e8b370fe9a5547bacd20ff84a0b6c3bc41288e5625"
dependencies = [
 "anyhow",
 "base64",
 "bstr",
 "fancy-regex",
 "lazy_static",
 "regex",
 "rustc-hash",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"


# --- File: ./src/main.rs ---

// src/main.rs

use anyhow::{Context, Result};
use clap::{Parser, ValueEnum};
use ignore::WalkBuilder;
use once_cell::sync::Lazy;
use std::collections::{HashMap, HashSet};
use std::fs;
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use std::process::Command;
use tiktoken_rs::p50k_base;

// Lazily initialized static map of predefined profiles. `once_cell` ensures thread-safe, one-time creation.
static PROFILES: Lazy<HashMap<&'static str, Profile>> = Lazy::new(|| {
    let mut m = HashMap::new();
    m.insert(
        "nextjs-ts-prisma",
        Profile {
            description: "Next.js, TypeScript, Prisma project files.",
            allowed_extensions: &[
                ".ts", ".tsx", ".js", ".jsx", ".json", ".css", ".scss", ".sass", ".less",
                ".html", ".htm", ".md", ".mdx", ".graphql", ".gql", ".env", ".env.local",
                ".env.development", ".env.production", ".yml", ".yaml", ".xml", ".toml",
                ".ini", ".vue", ".svelte", ".prisma",
            ],
            allowed_filenames: &[
                "next.config.js", "tailwind.config.js", "postcss.config.js",
                "middleware.ts", "middleware.js", "schema.prisma",
            ],
        },
    );
    m.insert(
        "cpp-cmake",
        Profile {
            description: "C/C++ and CMake project files.",
            allowed_extensions: &[
                ".c", ".cpp", ".cc", ".cxx", ".h", ".hpp", ".hh", ".ino", ".cmake",
                ".txt", ".md", ".json", ".xml", ".yml", ".yaml", ".ini", ".proto", ".fbs",
            ],
            allowed_filenames: &["CMakeLists.txt"],
        },
    );
    m.insert(
        "rust",
        Profile {
            description: "Rust project files.",
            allowed_extensions: &[
                ".rs", ".toml", ".md", ".yml", ".yaml", ".sh", ".json", ".html",
            ],
            allowed_filenames: &["Cargo.toml", "Cargo.lock", "build.rs", ".rustfmt.toml"],
        },
    );
    m
});

#[derive(Debug, Clone)]
struct Profile {
    description: &'static str,
    allowed_extensions: &'static [&'static str],
    allowed_filenames: &'static [&'static str],
}

#[derive(Parser, Debug)]
#[command(
    author,
    version,
    about = "A blazingly fast code flattener, written in Rust.",
    long_about = "Flattens code files from directories, filters by extension, and counts tokens, with profile support."
)]
struct Args {
    /// One or more directories to scan. Defaults to current directory.
    #[arg(default_value = ".")]
    target_dirs: Vec<PathBuf>,

    /// Output file path for the flattened code. If not specified, prints to console.
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Use a predefined profile for a specific project type.
    #[arg(short, long, value_enum)]
    profile: Option<ProfileChoice>,

    /// List all available profiles and their descriptions.
    #[arg(long)]
    list_profiles: bool,

    /// Comma-separated list of allowed file extensions (overrides profile).
    #[arg(short, long, value_delimiter = ',', use_value_delimiter = true)]
    extensions: Option<Vec<String>>,

    /// Space-separated list of specific filenames to include (overrides profile).
    #[arg(short, long, value_delimiter = ' ')]
    allowed_filenames: Option<Vec<String>>,

    /// Maximum file size to process in megabytes (MB).
    #[arg(long, default_value_t = 2.0)]
    max_size: f64,

    /// Format the output content using Markdown code blocks.
    #[arg(long)]
    markdown: bool,

    /// Use GPT-4 tokenizer for more accurate token counting.
    #[arg(long)]
    gpt4_tokens: bool,

    /// Append a section with current Git status and diffs.
    #[arg(short = 'g', long = "include-git-changes")]
    include_git_changes: bool,

    /// Do NOT include staged changes (git diff --staged).
    #[arg(long, requires = "include_git_changes")]
    no_staged_diff: bool,

    /// Do NOT include unstaged changes (git diff).
    #[arg(long, requires = "include_git_changes")]
    no_unstaged_diff: bool,

    /// Print verbose output during processing.
    #[arg(short, long)]
    verbose: bool,
}

// clap uses this enum to derive the possible values for the `--profile` argument.
#[derive(ValueEnum, Clone, Debug, PartialEq, Eq)]
enum ProfileChoice {
    #[clap(name = "nextjs-ts-prisma")]
    NextjsTsPrisma,
    #[clap(name = "cpp-cmake")]
    CppCmake,
    #[clap(name = "rust")]
    Rust,
}

fn main() -> Result<()> {
    let args = Args::parse();

    if args.list_profiles {
        list_profiles();
        return Ok(());
    }

    let mut extensions: HashSet<String> = HashSet::new();
    let mut allowed_filenames: HashSet<String> = HashSet::new();

    // Load settings from a profile if one was chosen.
    if let Some(profile_choice) = &args.profile {
        let profile_key = match profile_choice {
            ProfileChoice::NextjsTsPrisma => "nextjs-ts-prisma",
            ProfileChoice::CppCmake => "cpp-cmake",
            ProfileChoice::Rust => "rust",
        };
        if let Some(profile) = PROFILES.get(profile_key) {
            if args.verbose {
                println!("Using '{}' profile.", profile_key);
            }
            extensions.extend(profile.allowed_extensions.iter().map(|s| s.to_string()));
            allowed_filenames.extend(profile.allowed_filenames.iter().map(|s| s.to_string()));
        }
    }

    // Command-line arguments override any profile settings.
    if let Some(exts) = args.extensions {
        extensions = exts
            .into_iter()
            .map(|e| if e.starts_with('.') { e } else { format!(".{}", e) })
            .collect();
        if args.verbose {
            println!("Extensions overridden by command line: {:?}", extensions);
        }
    }
    if let Some(files) = args.allowed_filenames {
        allowed_filenames = files.into_iter().collect();
        if args.verbose {
            println!("Allowed filenames overridden by command line: {:?}", allowed_filenames);
        }
    }

    if extensions.is_empty() && allowed_filenames.is_empty() {
        anyhow::bail!("Error: No allowed extensions or filenames specified. Use a profile or provide them via flags.");
    }

    let mut all_contents = String::new();
    let mut file_count = 0;
    let max_file_size = (args.max_size * 1024.0 * 1024.0) as u64;

    println!("--- Starting Code Flattening ---");
    println!("Target Directories: {:?}", args.target_dirs);
    println!("Allowed Extensions: {:?}", extensions);
    if !allowed_filenames.is_empty() {
        println!("Allowed Filenames: {:?}", allowed_filenames);
    }
    println!("Max File Size: {:.2} MB", args.max_size);

    for start_dir in &args.target_dirs {
        // Use the `ignore` crate to recursively walk directories. It's fast and automatically respects .gitignore files.
        let walker = WalkBuilder::new(start_dir).build();
        for result in walker {
            let entry = match result {
                Ok(entry) => entry,
                Err(e) => {
                    eprintln!("Warning: Failed to process a directory entry: {}", e);
                    continue;
                }
            };
            
            let path = entry.path();
            if !path.is_file() {
                continue;
            }

            let file_name = path.file_name().unwrap_or_default().to_string_lossy();
            let extension = path.extension().unwrap_or_default().to_string_lossy();

            let is_allowed_ext = extensions.contains(&format!(".{}", extension));
            let is_allowed_file = allowed_filenames.contains(file_name.as_ref());

            if is_allowed_ext || is_allowed_file {
                match fs::metadata(path) {
                    Ok(metadata) => {
                        if metadata.len() > max_file_size {
                            if args.verbose {
                                println!(
                                    "Skipping large file ({:.2} KB): {}",
                                    metadata.len() as f64 / 1024.0,
                                    path.display()
                                );
                            }
                            continue;
                        }

                        match fs::read_to_string(path) {
                            Ok(content) => {
                                let file_path_str = path.to_string_lossy();
                                if args.markdown {
                                    all_contents.push_str(&format!(
                                        "\n\n```{}\n# --- File: {} ---\n",
                                        extension, file_path_str
                                    ));
                                    all_contents.push_str(&content);
                                    all_contents.push_str("\n```\n");
                                } else {
                                    all_contents.push_str(&format!(
                                        "\n\n# --- File: {} ---\n\n",
                                        file_path_str
                                    ));
                                    all_contents.push_str(&content);
                                }
                                file_count += 1;
                                if args.verbose {
                                    println!("Processed: {}", path.display());
                                }
                            }
                            Err(e) => {
                                // A common reason for failure is trying to read a non-UTF8 file.
                                eprintln!(
                                    "Warning: Could not read file {}: {} (skipping)",
                                    path.display(),
                                    e
                                );
                            }
                        }
                    }
                    Err(e) => {
                        eprintln!("Warning: Could not get metadata for {}: {}", path.display(), e);
                    }
                }
            }
        }
    }

    if args.include_git_changes {
        if let Ok(Some(root)) = find_git_root(args.target_dirs.get(0).unwrap_or(&PathBuf::from("."))) {
            if let Ok(Some(git_output)) = get_git_changes(
                &root,
                !args.no_staged_diff,
                !args.no_unstaged_diff,
                args.verbose,
            ) {
                all_contents.push_str(&git_output);
            }
        } else if args.verbose {
            eprintln!("Warning: Git repository not found in target directories.");
        }
    }

    let token_count = if args.gpt4_tokens {
        // p50k_base is a sensible default for GPT-3.5/4.
        p50k_base().unwrap().encode_with_special_tokens(&all_contents).len()
    } else {
        all_contents.split_whitespace().count()
    };

    if let Some(output_path) = args.output {
        if let Some(parent) = output_path.parent() {
             if !parent.exists() {
                fs::create_dir_all(parent)
                    .with_context(|| format!("Failed to create output directory: {}", parent.display()))?;
            }
        }
        fs::write(&output_path, &all_contents)
            .with_context(|| format!("Failed to write to output file: {}", output_path.display()))?;
        println!("\nFlattened code written to: {}", output_path.display());
    } else {
        // Lock stdout for a performance gain when writing large amounts of data.
        let mut stdout = io::stdout().lock();
        write!(stdout, "{}", all_contents)?;
    }
    
    // Print the final summary to stderr to avoid mixing it with the primary output,
    // which allows for clean piping (e.g., `flattener | pbcopy`).
    eprintln!("\n--- Processing Complete ---");
    eprintln!("Total files processed: {}", file_count);
    eprintln!("Approximate token count: {}", token_count);

    Ok(())
}

fn list_profiles() {
    println!("Available Profiles:");
    for (name, profile) in PROFILES.iter() {
        println!("  - {}: {}", name, profile.description);
        println!("    Extensions: {}", profile.allowed_extensions.join(", "));
        if !profile.allowed_filenames.is_empty() {
             println!("    Allowed Filenames: {}", profile.allowed_filenames.join(", "));
        }
        println!();
    }
}

/// Traverses up from `start_path` to find the repository root (containing a `.git` directory).
fn find_git_root(start_path: &Path) -> Result<Option<PathBuf>> {
    let mut current_path = fs::canonicalize(start_path)
        .with_context(|| format!("Failed to find canonical path for {}", start_path.display()))?;
    
    loop {
        if current_path.join(".git").is_dir() {
            return Ok(Some(current_path));
        }
        if !current_path.pop() {
            // Reached the filesystem root without finding a .git directory.
            return Ok(None);
        }
    }
}

/// Executes git commands to get status and diffs, returning them as a formatted string.
fn get_git_changes(
    git_repo_path: &Path,
    include_staged: bool,
    include_unstaged: bool,
    verbose: bool,
) -> Result<Option<String>> {
    let mut output = String::new();
    output.push_str("\n\n# --- Git Changes ---\n");
    output.push_str(&format!("# Repository: {}\n\n", git_repo_path.display()));

    let status_output = Command::new("git")
        .args(["status", "--porcelain", "-uall"])
        .current_dir(git_repo_path)
        .output()
        .context("Failed to execute 'git status'")?;

    if status_output.status.success() {
        let stdout = String::from_utf8_lossy(&status_output.stdout);
        if !stdout.trim().is_empty() {
            output.push_str("## Git Status (Staged, Unstaged, Untracked):\n```bash\n");
            output.push_str(stdout.trim());
            output.push_str("\n```\n\n");
        } else {
            output.push_str("## Git Status: No uncommitted changes.\n\n");
        }
    } else if verbose {
        eprintln!("'git status' failed: {}", String::from_utf8_lossy(&status_output.stderr));
    }
    
    if include_staged {
        let diff_output = Command::new("git")
            .args(["diff", "--staged"])
            .current_dir(git_repo_path)
            .output().context("Failed to execute 'git diff --staged'")?;

        if diff_output.status.success() {
             let stdout = String::from_utf8_lossy(&diff_output.stdout);
             if !stdout.trim().is_empty() {
                 output.push_str("## Git Diff (Staged Changes):\n```diff\n");
                 output.push_str(stdout.trim());
                 output.push_str("\n```\n\n");
             }
        } else if verbose {
             eprintln!("'git diff --staged' failed: {}", String::from_utf8_lossy(&diff_output.stderr));
        }
    }

    if include_unstaged {
        let diff_output = Command::new("git")
            .args(["diff"])
            .current_dir(git_repo_path)
            .output().context("Failed to execute 'git diff'")?;

        if diff_output.status.success() {
             let stdout = String::from_utf8_lossy(&diff_output.stdout);
             if !stdout.trim().is_empty() {
                 output.push_str("## Git Diff (Unstaged Changes):\n```diff\n");
                 output.push_str(stdout.trim());
                 output.push_str("\n```\n\n");
             }
        } else if verbose {
             eprintln!("'git diff' failed: {}", String::from_utf8_lossy(&diff_output.stderr));
        }
    }
    
    Ok(Some(output))
}

# --- File: ./Todo.md ---

# Development Plan & TODO

This document outlines future enhancements to make the code flattener more powerful and intuitive for users.

## 1. External Profile Configuration (High Priority)

The current method of hardcoding profiles in a `static HashMap` is inflexible. The tool should support user-defined profiles loaded from an external file.

-   **Goal:** Allow users to add or customize profiles without recompiling the application.
-   **Proposed Solution:**
    1.  **Config File:** Use a TOML file (e.g., `profiles.toml`).
    2.  **Location:** Search for the config file in standard locations (e.g., user's config directory, project root). The `dirs` crate can help find platform-specific config paths.
    3.  **Implementation:**
        -   Use `serde` for deserializing the TOML file into structs.
        -   At startup, load the default built-in profiles, then load and merge profiles from the user's config file, with user-defined profiles overriding defaults.
    4.  **Dynamic CLI:** The `--profile` argument needs to be dynamically populated from the loaded profile names. This is a known challenge with `clap::value_enum` and may require using `clap::builder::PossibleValuesParser` or a similar dynamic approach instead of the derive macro.

### 2. Project Type Auto-Detection

-   **Goal:** Improve usability by suggesting a profile if none is provided.
-   **Proposed Solution:**
    -   If the `--profile` flag is omitted, scan the target directory for key indicator files (`Cargo.toml`, `package.json`, `CMakeLists.txt`, `pom.xml`, etc.).
    -   If a likely project type is identified, either automatically apply that profile or prompt the user to confirm.

### 3. Enhanced Git Integration

-   **Goal:** Provide more granular control over what Git information is included.
-   **Proposed Solution:**
    -   Add a flag to include the output of `git log -n <count>` to show recent commit history.
    -   Add a flag to diff against a specific branch (e.g., `main` or `develop`) instead of just local staged/unstaged changes.

### 4. Code Quality & Refinements

-   **Configuration Loading:** Abstract the configuration logic (profiles, overrides, etc.) into its own module (`config.rs`) to clean up `main.rs`.
-   **Error Handling:** Improve warnings. For example, when a file can't be read, explicitly state if it's being skipped due to a non-UTF8 encoding issue.


# --- File: ./README.md ---

# CodeFlattener
A blazingly-fast, rust based, cli program to flatten a codebased to upload to AIStudio
